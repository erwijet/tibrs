use std::io::Write;

use crate::TibToken;
use anyhow::{Context, Result};

struct TIVariableSection {
    name: [u8; 8],
    data: Box<[u8]>,
}

impl TIVariableSection {
    fn get_checksum(&self) -> u16 {
        println!("checksum");

        let sum: u64 = self.data.iter().fold(0, |sum, cur| sum + (*cur as u64));

        (sum & 0xFFFF).try_into().unwrap() // take only lower 16 bits
    }
}

impl From<TIVariableSection> for Box<[u8]> {
    fn from(value: TIVariableSection) -> Self {
        let mut buf = Vec::<u8>::new();

        buf.extend_from_slice(&[0x0D, 0x0]); // section signature
        buf.extend_from_slice(&(value.data.len() as u16 + 2).to_le_bytes());
        buf.extend_from_slice(&[0x05]); // section type (PRGM)
        buf.extend_from_slice(&value.name);
        buf.extend_from_slice(&[0x0]); // version
        buf.extend_from_slice(&[0x0]); // flag: 0x0 indicates unarchived
        buf.extend_from_slice(&(value.data.len() as u16 + 2).to_le_bytes());

        buf.extend_from_slice(&(value.data.len() as u16).to_le_bytes());
        buf.extend_from_slice(&value.data);

        buf.into_boxed_slice()
    }
}

pub fn compile(tokens: Vec<TibToken>) -> Result<Vec<u8>> {
    // NOTE: TI uses little-endian for all binary reprs

    let comment: [u8; 42] = {
        let mut buf: [u8; 42] = [0; 42];
        let str_bytes = b"Generated by the TI-BASIC Compiler";

        buf[..str_bytes.len()].copy_from_slice(str_bytes);
        buf
    };

    let data_section = TIVariableSection {
        name: *b"ABCDEFGH",
        data: {
            let mut buf = Vec::<u8>::new();

            for tok in tokens {
                buf.extend_from_slice(&hex::decode(
                    tok.hex_str
                        .strip_prefix("0x")
                        .with_context(|| format!("Malformated hex: '{}'", tok.hex_str))?,
                )?);
            }

            buf.into()
        },
    };

    let mut buf = Vec::<u8>::new();

    // write file header

    buf.extend_from_slice("**TI83F*".as_bytes()); // file format sig
    buf.extend_from_slice(&[0x1A, 0x0A, 0x0]); // ext sig
    buf.extend_from_slice(&comment);

    let checksum  = data_section.get_checksum();
    let data_buf: Box<[u8]> = data_section.into();

    buf.extend_from_slice(&(data_buf.len() as u16).to_le_bytes());

    buf.extend_from_slice(&*data_buf);

    buf.extend_from_slice(&checksum.to_le_bytes());

    Ok(buf)
}
